#include <windows.h>
#include <winsock.h>
#include <ctype.h>
#include <winuser.h>
#include <wtsapi32.h>
typedef int socklen_t;

#include <stdio.h>
#include "CreateUserDaemon.h"
#include <string>
#include <ssoclient.h>
#include <lm.h>
#include <msg.h>

extern HANDLE hEventLog;
extern const wchar_t* generatePassword();
extern const wchar_t * errorMessage(int error);

CreateUserDaemon::CreateUserDaemon() {
	socket_in = 0;
	publicSocket = 0;
	stop = false;
}

int CreateUserDaemon::getErrorNumber() {
#ifdef WIN32
	return WSAGetLastError();
#else
	return errno;
#endif
}

///////////////////////////////////////////////////////////7
void CreateUserDaemon::createInputSocket() {
	socklen_t size;
	SOCKADDR_IN addrin;
	socket_in = socket(PF_INET, SOCK_STREAM, 0);
	SeyconCommon::debug("Created socket: %d\n", (int) socket_in);
	size = sizeof addrin;
	if (socket_in < 0) {
		fprintf(stderr, "Error creating socket\n");
		return;
	}
	addrin.sin_family = AF_INET;
	addrin.sin_addr.s_addr = inet_addr("127.0.0.1");
	addrin.sin_port = 0;
	if (bind(socket_in, (LPSOCKADDR) &addrin, sizeof(addrin)) != 0) {
		printf("Error linking socket\n");
		return;
	}
	if (getsockname(socket_in, (LPSOCKADDR) &addrin, &size) != 0) {
		fprintf(stderr, "Error obtaining socket name:%d \n", getErrorNumber());
		return;
	}
	publicSocket = ntohs(addrin.sin_port);
	if (listen(socket_in, 2) != 0) {
		fprintf(stderr, "Error listening port\n");
		return;
	}
	char achPort[10];
	sprintf (achPort, "%d", (int) publicSocket);
	SeyconCommon::writeProperty("createUserSocket", achPort);
	printf ("Listening on port %d\n", publicSocket);
}

struct ThreadParam {
public:
	ThreadParam(CreateUserDaemon *d, SOCKET s) {
		this->daemon = d;
		this->s = s;
	}
	CreateUserDaemon *daemon;
	SOCKET s;
};

//////////////////////////////////////////////////////////
#ifdef WIN32
static int WINAPI _s_handleConnection(LPVOID lpv)
#else
		static void* _s_handleConnection (void * lpv)
#endif
		{
	ThreadParam *p = (ThreadParam*) lpv;
	p->daemon->handleConnection(p->s);
	delete p;
#ifdef WIN32
	ExitThread(0);
	return 0;
#else
	pthread_exit (NULL);
	return NULL;
#endif
}

static int counter = 1;

static bool existsUser(const wchar_t* user) {
	LPBYTE buffer;

	DWORD result = NetUserGetInfo(NULL, // Local Host
			user, 2, // level
			&buffer);

	NetApiBufferFree(buffer);

	if (result == NERR_UserNotFound)
		return false;
	else
		return true;
}

static bool createUser(const wchar_t* user, std::wstring pass) {
	USER_INFO_2 ui2;
	memset(&ui2, 0, sizeof ui2);
	ui2.usri2_name = (wchar_t*) user;
	ui2.usri2_password = (wchar_t*) pass.c_str();
	ui2.usri2_priv = USER_PRIV_USER;
	ui2.usri2_comment = (wchar_t*) L"Autogenerated by Soffid";
	ui2.usri2_flags = UF_NORMAL_ACCOUNT;
	ui2.usri2_full_name = (wchar_t*) L"Soffid temporary user";
	ui2.usri2_acct_expires = TIMEQ_FOREVER;
	DWORD error;
	DWORD result = NetUserAdd(NULL, 2, (LPBYTE) &ui2, &error);
	if (result != NERR_Success) {
		const wchar_t * params[2] = { user, errorMessage(result) };
		ReportEventW(hEventLog, EVENTLOG_INFORMATION_TYPE, SHIRO_CATEGORY,
				SHIRO_LOCALERROR,
				NULL, 1, 0, (LPCWSTR*) &params, NULL);

		return false;
	}
	return true;
}

static bool updateUser(const wchar_t* user, std::wstring pass) {
	LPBYTE buffer;
	DWORD error;
	DWORD result = NetUserGetInfo(NULL, // Local Host
			user, 2, // level
			&buffer);

	if (result != NERR_Success)
		return false;

	USER_INFO_2 *ui2 = (USER_INFO_2*) buffer;

	wchar_t *passStr = wcsdup (pass.c_str());
	ui2->usri2_password = passStr;
	ui2->usri2_flags = UF_NORMAL_ACCOUNT;

	result = NetUserSetInfo(NULL, user, 2, (LPBYTE) ui2, &error);

	NetApiBufferFree(buffer);

	memset (passStr, 0, pass.length());
	free (passStr);

	if (result != NERR_Success) {
		const wchar_t *params[2] = { user, errorMessage(result) };
		ReportEventW(hEventLog, EVENTLOG_ERROR_TYPE, SHIRO_CATEGORY,
				SHIRO_LOCALERROR, NULL, 2, 0, (LPCWSTR*) &params,
				NULL);
		return false;
	}
	return true;

}

void CreateUserDaemon::handleConnection(SOCKET s) {
	std::string maxString;
	std::string enabled;
	SOCKADDR_IN addrin;
	socklen_t size = sizeof addrin;

	if (getsockname(s, (LPSOCKADDR) &addrin, &size) != 0) {
		fprintf(stderr, "Error obtaining socket name:%d \n", getErrorNumber());
	} else {
		int publicSocket = ntohs(addrin.sin_port);
		const char *remote = inet_ntoa(addrin.sin_addr);

		printf ("Received connection from %s:%d\n", remote, publicSocket);
	}

	SeyconCommon::readProperty("maxLocalAccounts", maxString);
	SeyconCommon::readProperty("enableLocalAccounts", enabled);
	if (enabled == "true")
	{
		int max = 30;
		sscanf(maxString.c_str(), " %d", &max);
		if (counter > max)
			counter = 1;
		int next = counter++;

		wchar_t userName[30];
		swprintf(userName, L"ShiroUser_%d", next);

		const wchar_t *params = userName;
		ReportEventW(hEventLog, EVENTLOG_INFORMATION_TYPE, SHIRO_CATEGORY,
				SHIRO_CREATE_USER,
				NULL, 1, 0, (LPCWSTR*) &params, NULL);

		std::wstring newPass = generatePassword();
		if (existsUser(userName))
			updateUser(userName, newPass.c_str());
		else
			createUser(userName, newPass.c_str());

		Sleep ( 1000 ); // Wait for a second

		std::wstring response = userName;
		response += L'\n';
		response += newPass;
		int len = sizeof(wchar_t) * (response.length() + 1);
		send(s, (const char*) response.c_str(), len, 0);
		printf ("Response:\n%ls\n", response.c_str());
	}
	closesocket(s);
}

//////////////////////////////////////////////////////////
static int WINAPI _s_startLoop(LPVOID lpv) {
	ThreadParam *p = (ThreadParam*) lpv;
	p->daemon->run();
//	delete p;
	ExitThread(0);
	return 0;
}


void CreateUserDaemon::run() {
	SOCKADDR addr;
	SOCKET s;
	socklen_t len;

	while (!stop) {
		len = sizeof addr;
		s = accept(socket_in, &addr, &len);

		if (stop || s == (SOCKET) -1) {
#ifdef WIN32
			ExitThread(0);
#else
			pthread_exit (NULL);
#endif
		} else {
			ThreadParam *data = new ThreadParam(this, s);
#ifdef WIN32
			HANDLE hThread;
			hThread = CreateThread(NULL, 0,
					(LPTHREAD_START_ROUTINE) _s_handleConnection, (LPVOID) data,
					0, (LPDWORD) &hThread);
			CloseHandle(hThread);
#else
			pthread_t thread1;
			pthread_create( &thread1, NULL, _s_handleConnection, (void*) data);
#endif
		}
	}
}

//////////////////////////////////////////////////////////
int CreateUserDaemon::startDaemon() {
	WSADATA wsaData;
	WSAStartup(MAKEWORD(1, 1), &wsaData);

	createInputSocket();

	ThreadParam *data = new ThreadParam(this, socket_in);
	ThreadParam *data2 = new ThreadParam(this, socket_in);
	stop = false;
	DWORD dwThreadId, dwThreadId2;
	HANDLE hThreadListen = CreateThread(NULL, 0,
			(LPTHREAD_START_ROUTINE) _s_startLoop, (LPVOID) data, 0,
			&dwThreadId);

	CloseHandle(hThreadListen);

	return publicSocket;
}

//////////////////////////////////////////////////////////
void CreateUserDaemon::stopDaemon() {
	stop = true;
#ifdef WIN32
	closesocket(socket_in);
#else
	close (socket_in);
#endif
}

